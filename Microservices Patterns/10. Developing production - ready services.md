# Developing production ready services

## Security

![img_176.png](img_176.png)

![img_177.png](img_177.png)

A better approach is for the API gateway to authenticate a request before forwarding it to the services.

![img_178.png](img_178.png)

![img_179.png](img_179.png)

Authenticating a clientâ€™s credentials is important but insufficient. An application must also implement an authorization
mechanism that verifies that the client is allowed to perform the requested operation. For example, in the FTGO
application the getOrderDetails() query can only be invoked by the consumer who placed the Order (an example of
instance-based security) and a customer service agent who is helping the consumer

## Using OAuth 2.0

![img_180.png](img_180.png)

![img_181.png](img_181.png)

![img_182.png](img_182.png)

![img_183.png](img_183.png)

![img_184.png](img_184.png)

![img_185.png](img_185.png)

## Designing configurable services

![img_186.png](img_186.png)

![img_187.png](img_187.png)

![img_188.png](img_188.png)

### Push - based approach

![img_189.png](img_189.png)

### Pull - based approach

![img_190.png](img_190.png)

![img_191.png](img_191.png)

![img_192.png](img_192.png)

### Must have patterns

There are several patterns that you, as a service developer, must implement to make your service easier to manage and
troubleshoot.

![img_193.png](img_193.png)

![img_194.png](img_194.png)

![img_195.png](img_195.png)

### Health check API pattern

![img_196.png](img_196.png)

### Log aggregation pattern


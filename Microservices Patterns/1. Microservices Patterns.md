# Microservices Patterns 

## Scaling application

![img.png](img.png)

![img_1.png](img_1.png)

![img_2.png](img_2.png)

![img_3.png](img_3.png)

## Pattern language

![img_5.png](img_5.png)

![img_4.png](img_4.png)

![img_6.png](img_6.png)

![img_7.png](img_7.png)

![img_8.png](img_8.png)

![img_9.png](img_9.png)

![img_10.png](img_10.png)

![img_11.png](img_11.png)

![img_12.png](img_12.png)

## 4 + 1 view model 

![img_13.png](img_13.png)

![img_14.png](img_14.png)

![img_15.png](img_15.png)

An application has two categories of requirements: functional and quality of 
service. Architecture has very little to do with first you can implement all
of them using a big ball of mud. But it is important to satisfy the second, 
these are also known as quality attributes, or ilities, which defines the 
scalability and reliability, and also edfine maintainability, testability,
deployability.

## Architectural styles

Layer and Hexagonal Architecture are both organise the logical view 

### Layer Architecture

![img_16.png](img_16.png)

### Hexagonal Architecture

![img_17.png](img_17.png)

![img_18.png](img_18.png)

![img_19.png](img_19.png)

![img_20.png](img_20.png)

![img_21.png](img_21.png)

## Defining microservices architecture

![img_22.png](img_22.png)

### Identifying system operations

![img_23.png](img_23.png)

![img_24.png](img_24.png)

![img_25.png](img_25.png)

![img_26.png](img_26.png)

![img_27.png](img_27.png)

### Defining system operations

![img_28.png](img_28.png)

![img_29.png](img_29.png)

![img_30.png](img_30.png)

![img_31.png](img_31.png)

### Defining microservices by applying business capability pattern

![img_32.png](img_32.png)

![img_33.png](img_33.png)

![img_34.png](img_34.png)

### Defining services by applying the Decompose by sub-domain pattern

![img_35.png](img_35.png)

## Defining service APIs

![img_36.png](img_36.png)

![img_37.png](img_37.png)

![img_38.png](img_38.png)

## Inter process communication


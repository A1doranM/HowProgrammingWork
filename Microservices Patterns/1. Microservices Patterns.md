# Microservices Patterns 

## Scaling application

![img.png](img.png)

![img_1.png](img_1.png)

![img_2.png](img_2.png)

![img_3.png](img_3.png)

## Pattern language

![img_5.png](img_5.png)

![img_4.png](img_4.png)

![img_6.png](img_6.png)

![img_7.png](img_7.png)

![img_8.png](img_8.png)

![img_9.png](img_9.png)

![img_10.png](img_10.png)

![img_11.png](img_11.png)

![img_12.png](img_12.png)

## 4 + 1 view model 

![img_13.png](img_13.png)

![img_14.png](img_14.png)

![img_15.png](img_15.png)

An application has two categories of requirements: functional and quality of 
service. Architecture has very little to do with first you can implement all
of them using a big ball of mud. But it is important to satisfy the second, 
these are also known as quality attributes, or ilities, which defines the 
scalability and reliability, and also edfine maintainability, testability,
deployability.

## Architectural styles

Layer and Hexagonal Architecture are both organise the logical view 

### Layer Architecture

![img_16.png](img_16.png)

### Hexagonal Architecture

![img_17.png](img_17.png)

![img_18.png](img_18.png)

![img_19.png](img_19.png)

![img_20.png](img_20.png)

![img_21.png](img_21.png)

## Defining microservices architecture

![img_22.png](img_22.png)

### Identifying system operations

![img_23.png](img_23.png)

![img_24.png](img_24.png)

![img_25.png](img_25.png)

![img_26.png](img_26.png)

![img_27.png](img_27.png)

### Defining system operations

![img_28.png](img_28.png)

![img_29.png](img_29.png)

![img_30.png](img_30.png)

![img_31.png](img_31.png)

### Defining microservices by applying business capability pattern

![img_32.png](img_32.png)

![img_33.png](img_33.png)

![img_34.png](img_34.png)

### Defining services by applying the Decompose by sub-domain pattern

![img_35.png](img_35.png)

## Defining service APIs

![img_36.png](img_36.png)

![img_37.png](img_37.png)

![img_38.png](img_38.png)

## Inter process communication

![img_39.png](img_39.png)

![img_40.png](img_40.png)

![img_41.png](img_41.png)

### Versioning

![img_42.png](img_42.png)

![img_43.png](img_43.png)

### Communicating using the synchronous Remote procedure invocation pattern

![img_44.png](img_44.png)

#### Using REST

![img_45.png](img_45.png)

![img_46.png](img_46.png)

#### Using gRPC

![img_47.png](img_47.png)
![img_48.png](img_48.png)

![img_49.png](img_49.png)

#### Handling partial failure. Circuit breaker pattern

![img_50.png](img_50.png)

![img_51.png](img_51.png)

##### Developing robust RPI proxies

Whenever one service synchronously invokes another service, it should protect itself
using the approach described by Netflix

![img_52.png](img_52.png)

##### Recovering from unavailable service

One option is for a service to simply return an error to its client. For example,
this approach makes sense for the scenario shown in figure 3.2, where the request to
create an Order fails. The only option is for the API gateway to return an error to the
mobile client.

![img_53.png](img_53.png)

![img_54.png](img_54.png)

#### Using service discovery

Service instances have dynamically assigned network locations. Moreover, the set of
service instances changes dynamically because of autoscaling, failures, and upgrades.
Consequently, your client code must use a service discovery.

![img_55.png](img_55.png)

![img_56.png](img_56.png)

![img_57.png](img_57.png)

##### APPLYING THE PLATFORM-PROVIDED SERVICE DISCOVERY PATTERNS

Many modern deployment platforms such as
Docker and Kubernetes have a built-in service registry and service discovery mechanism. The deployment platform gives each service a DNS name, a virtual IP (VIP)
address, and a DNS name that resolves to the VIP address. A service client makes a
request to the DNS name/VIP, and the deployment platform automatically routes the
request to one of the available service instances. As a result, service registration, service discovery, and request routing are entirely handled by the deployment platform.

![img_58.png](img_58.png)

![img_59.png](img_59.png)

The key benefit of platform-provided service discovery is that all aspects of service discovery are entirely handled by the deployment platform. Neither the services nor the
clients contain any service discovery code. Consequently, the service discovery mechanism is readily available to all services and clients regardless of which language or
framework they’re written in. One drawback of platform-provided service discovery is that it only supports the
discovery of services that have been deployed using the platform. For example, as
mentioned earlier when describing application-level discovery, Kubernetes-based discovery only works for services running on Kubernetes. Despite this limitation, I recommend using platform-provided service discovery whenever possible

### Using Asynchronous messaging pattern

![img_60.png](img_60.png)

![img_61.png](img_61.png)

![img_62.png](img_62.png)

![img_63.png](img_63.png)

![img_64.png](img_64.png)

![img_65.png](img_65.png)

![img_66.png](img_66.png)

![img_67.png](img_67.png)

![img_68.png](img_68.png)

### Creating an API specification for a messaging-based service API

You must also describe the format of the messages using a
standard such as JSON, XML, or Protobuf. But unlike with REST and Open API, there
isn’t a widely adopted standard for documenting the channels and the message types.
Instead, you need to write an informal document.

A service’s asynchronous API consists of operations, invoked by clients, and events,
published by the services. They’re documented in different ways.

![img_69.png](img_69.png)

#### Documenting asynchronous operations

![img_70.png](img_70.png)

#### Documenting published events

A service can also publish events using a publish/subscribe interaction style. The specification of this style of API consists of the event channel and the types and formats of
the event messages that are published by the service to the channel.
The messages and channels model of messaging is a great abstraction and a good
way to design a service’s asynchronous API. But in order to implement a service you
need to choose a messaging technology and determine how to implement your design
using its capabilities.

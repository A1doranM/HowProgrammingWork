# Настройка HTTPS для web-app в Kubernetes. NGINX Ingress и cert manager. Let's Encrypt

Для начала нам понадобится публичное доменное имя которое можно купить например на Амазон, в нашем случае это имя "
bakavets.com".

Перейдем в выделенную на Амазоне машину с настроенным пустым кластером

Запустим два деплоймента каждый из которых содержит две разные версии одного приложения deploy-svc-app-1.yaml,
deploy-svc-app-2.yaml

    kubectl apply -f deploy-svc-app-1.yaml

    kubectl apply -f deploy-svc-app-2.yaml

## Настройка NGINX Ingress Controller

Является самым универсальным ингресс контроллером и устанавливается на большинство провайдеров. Установим его в наш
кластер чтобы затем настроить при под наши нужды.

    kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v0.46.0/deploy/static/provider/aws/deploy.yaml

Посмотрим список сервисов который создался контроллером

    kubectl get svc -n ingress-nginx

![img.png](img.png)

Как видим был создан LoadBalancer с адресом по которому мы будем обращаться к нему.

Теперь задеплоим настроенный Ingress контроллер для двух наших деплойментов

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: main-ingress
  annotations:
    kubernetes.io/ingress.class: nginx
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
spec:
  tls:
    - hosts:
        - app-1.bakavets.com
        - app-2.bakavets.com
      secretName: app-tls
  rules:
    - host: app-1.bakavets.com # Сабдомен app-1.bakavets.com относится к первому приложению 
      http:
        paths:
          - pathType: Prefix
            path: /
            backend:
              service:
                name: kuber-service-1
                port:
                  number: 80
    - host: app-2.bakavets.com # Сабдомен app-2.bakavets.com относится к второму приложению
      http:
        paths:
          - pathType: Prefix
            path: /
            backend:
              service:
                name: kuber-service-2
                port:
                  number: 80
```

    kubectl apply -f ingress.yaml

Сейчас мы уже можем обращаться к нашему контроллеру и через него к приложениям, попробуем сделать базовый curl на них

![img_1.png](img_1.png)

И как видим мы получаем ответ от первой версии приложения.

И то же самое для второй версии

![img_2.png](img_2.png)

Теперь попробуем выяснить IP адрес принадлежащий этому LoadBalancer при помощи команды nslookup. Стоит учесть что
например в Amazon есть такое понятие как Availability Zones и на самом деле ип адресов у LoadBalancer будет столько
сколько есть зон в которых ему дозволено работать, если выполнять команду nslookup несколько раз то рано, или поздно мы
увидим все ip адреса.

    nslookup a9966ee6ed24a49b295675ca5662547c-66fb027b46e6c4c3.elb.eu-north-1.amazonaws.com

![img_3.png](img_3.png)

Дальше перейдем в настройки нашего хостинга и добавим DNS запись типа А указав ей значение IP адреса балансировщика и
домен app-1 (итоговый адрес будет app-1.bakavets.com, bakavets.com добавится автоматически так как это само доменное
имя) для первого приложения и еще одну запись с доменом app-2 для второго.

![img_4.png](img_4.png)

Зайдя в браузер мы можем получить доступ к нашему приложению просто из интеренета

![img_5.png](img_5.png)

## Настройка HTTPS сертификата

cert-manager - нативный Kubernetes менеджер сертификатов. 

![img_6.png](img_6.png)

